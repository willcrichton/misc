<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Closures: Anonymous Functions that Capture Their Environment - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="js-extensions/packages/consent-form/dist/index.css">
        <link rel="stylesheet" href="js-extensions/packages/feedback/dist/index.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="experiment-intro.html">Experiment Introduction</a></li><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-fixing-ownership-errors.html"><strong aria-hidden="true">4.3.</strong> Fixing Ownership Errors</a></li><li class="chapter-item expanded "><a href="ch04-04-slices.html"><strong aria-hidden="true">4.4.</strong> The Slice Type</a></li><li class="chapter-item expanded "><a href="ch04-05-ownership-recap.html"><strong aria-hidden="true">4.5.</strong> Ownership Recap</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li><li class="chapter-item expanded "><a href="ch06-04-inventory.html"><strong aria-hidden="true">6.4.</strong> Ownership Inventory #1</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li><li class="chapter-item expanded "><a href="ch08-04-inventory.html"><strong aria-hidden="true">8.4.</strong> Ownership Inventory #2</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li><li class="chapter-item expanded "><a href="ch10-04-inventory.html"><strong aria-hidden="true">10.4.</strong> Ownership Inventory #3</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html" class="active"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li><li class="chapter-item expanded "><a href="ch17-04-inventory.html"><strong aria-hidden="true">17.4.</strong> Ownership Inventory #4</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="end-of-experiment.html"><strong aria-hidden="true">21.</strong> End of Experiment</a></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cognitive-engineering-lab/rust-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Old heading. Do not remove or links may break. -->
<p><a id="closures-anonymous-functions-that-can-capture-their-environment"></a></p>
<h2 id="closures-anonymous-functions-that-capture-their-environment"><a class="header" href="#closures-anonymous-functions-that-capture-their-environment">Closures: Anonymous Functions that Capture Their Environment</a></h2>
<p>Rust’s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure elsewhere to evaluate it in a different context. Unlike
functions, closures can capture values from the scope in which they’re defined.
We’ll demonstrate how these closure features allow for code reuse and behavior
customization.</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a></p>
<h3 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></h3>
<p>We’ll first examine how we can use closures to capture values from the
environment they’re defined in for later use. Here’s the scenario: Every so
often, our t-shirt company gives away an exclusive, limited-edition shirt to
someone on our mailing list as a promotion. People on the mailing list can
optionally add their favorite color to their profile. If the person chosen for
a free shirt has their favorite color set, they get that color shirt. If the
person hasn’t specified a favorite color, they get whatever color the company
currently has the most of.</p>
<p>There are many ways to implement this. For this example, we’re going to use an
enum called <code>ShirtColor</code> that has the variants <code>Red</code> and <code>Blue</code> (limiting the
number of colors available for simplicity). We represent the company’s
inventory with an <code>Inventory</code> struct that has a field named <code>shirts</code> that
contains a <code>Vec&lt;ShirtColor&gt;</code> representing the shirt colors currently in stock.
The method <code>giveaway</code> defined on <code>Inventory</code> gets the optional shirt
color preference of the free shirt winner, and returns the shirt color the
person will get. This setup is shown in Listing 13-1:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust noplayground">#[derive(Debug, PartialEq, Copy, Clone)]
enum ShirtColor {
    Red,
    Blue,
}

struct Inventory {
    shirts: Vec&lt;ShirtColor&gt;,
}

impl Inventory {
    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {
        user_preference.unwrap_or_else(|| self.most_stocked())
    }

    fn most_stocked(&amp;self) -&gt; ShirtColor {
        let mut num_red = 0;
        let mut num_blue = 0;

        for color in &amp;self.shirts {
            match color {
                ShirtColor::Red =&gt; num_red += 1,
                ShirtColor::Blue =&gt; num_blue += 1,
            }
        }
        if num_red &gt; num_blue {
            ShirtColor::Red
        } else {
            ShirtColor::Blue
        }
    }
}

fn main() {
    let store = Inventory {
        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    let user_pref1 = Some(ShirtColor::Red);
    let giveaway1 = store.giveaway(user_pref1);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref1, giveaway1
    );

    let user_pref2 = None;
    let giveaway2 = store.giveaway(user_pref2);
    println!(
        &quot;The user with preference {:?} gets {:?}&quot;,
        user_pref2, giveaway2
    );
}</code></pre>
<p><span class="caption">Listing 13-1: Shirt company giveaway situation</span></p>
<p>The <code>store</code> defined in <code>main</code> has two blue shirts and one red shirt remaining
to distribute for this limited-edition promotion. We call the <code>giveaway</code> method
for a user with a preference for a red shirt and a user without any preference.</p>
<p>Again, this code could be implemented in many ways, and here, to focus on
closures, we’ve stuck to concepts you’ve already learned except for the body of
the <code>giveaway</code> method that uses a closure. In the <code>giveaway</code> method, we get the
user preference as a parameter of type <code>Option&lt;ShirtColor&gt;</code> and call the
<code>unwrap_or_else</code> method on <code>user_preference</code>. The <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code> method on
<code>Option&lt;T&gt;</code></a><!-- ignore --> is defined by the standard library.
It takes one argument: a closure without any arguments that returns a value <code>T</code>
(the same type stored in the <code>Some</code> variant of the <code>Option&lt;T&gt;</code>, in this case
<code>ShirtColor</code>). If the <code>Option&lt;T&gt;</code> is the <code>Some</code> variant, <code>unwrap_or_else</code>
returns the value from within the <code>Some</code>. If the <code>Option&lt;T&gt;</code> is the <code>None</code>
variant, <code>unwrap_or_else</code> calls the closure and returns the value returned by
the closure.</p>
<p>We specify the closure expression <code>|| self.most_stocked()</code> as the argument to
<code>unwrap_or_else</code>. This is a closure that takes no parameters itself (if the
closure had parameters, they would appear between the two vertical bars). The
body of the closure calls <code>self.most_stocked()</code>. We’re defining the closure
here, and the implementation of <code>unwrap_or_else</code> will evaluate the closure
later if the result is needed.</p>
<p>Running this code prints:</p>
<pre><code class="language-console">$ cargo run
   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/shirt-company`
The user with preference Some(Red) gets Red
The user with preference None gets Blue
</code></pre>
<p>One interesting aspect here is that we’ve passed a closure that calls
<code>self.most_stocked()</code> on the current <code>Inventory</code> instance. The standard library
didn’t need to know anything about the <code>Inventory</code> or <code>ShirtColor</code> types we
defined, or the logic we want to use in this scenario. The closure captures an
immutable reference to the <code>self</code> <code>Inventory</code> instance and passes it with the
code we specify to the <code>unwrap_or_else</code> method. Functions, on the other hand,
are not able to capture their environment in this way.</p>
<h3 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></h3>
<p>There are more differences between functions and closures. Closures don’t
usually require you to annotate the types of the parameters or the return value
like <code>fn</code> functions do. Type annotations are required on functions because the
types are part of an explicit interface exposed to your users. Defining this
interface rigidly is important for ensuring that everyone agrees on what types
of values a function uses and returns. Closures, on the other hand, aren’t used
in an exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>Closures are typically short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler can
infer the types of the parameters and the return type, similar to how it’s able
to infer the types of most variables (there are rare cases where the compiler
needs closure type annotations too).</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for a closure would look like the definition
shown in Listing 13-2. In this example, we’re defining a closure and storing it
in a variable rather than defining the closure in the spot we pass it as an
argument as we did in Listing 13-1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn generate_workout(intensity: u32, random_number: u32) {
</span>    let expensive_closure = |num: u32| -&gt; u32 {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };
<span class="boring">
</span><span class="boring">    if intensity &lt; 25 {
</span><span class="boring">        println!(&quot;Today, do {} pushups!&quot;, expensive_closure(intensity));
</span><span class="boring">        println!(&quot;Next, do {} situps!&quot;, expensive_closure(intensity));
</span><span class="boring">    } else {
</span><span class="boring">        if random_number == 3 {
</span><span class="boring">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
</span><span class="boring">        } else {
</span><span class="boring">            println!(
</span><span class="boring">                &quot;Today, run for {} minutes!&quot;,
</span><span class="boring">                expensive_closure(intensity)
</span><span class="boring">            );
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let simulated_user_specified_value = 10;
</span><span class="boring">    let simulated_random_number = 7;
</span><span class="boring">
</span><span class="boring">    generate_workout(simulated_user_specified_value, simulated_random_number);
</span><span class="boring">}</span></code></pre></pre>
<p><span class="caption">Listing 13-2: Adding optional type annotations of the
parameter and return value types in the closure</span></p>
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. Here we define a function that adds 1 to its parameter and
a closure that has the same behavior, for comparison. We’ve added some spaces
to line up the relevant parts. This illustrates how closure syntax is similar
to function syntax except for the use of pipes and the amount of syntax that is
optional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
<p>The first line shows a function definition, and the second line shows a fully
annotated closure definition. In the third line, we remove the type annotations
from the closure definition. In the fourth line, we remove the brackets, which
are optional because the closure body has only one expression. These are all
valid definitions that will produce the same behavior when they’re called. The
<code>add_one_v3</code> and <code>add_one_v4</code> lines require the closures to be evaluated to be
able to compile because the types will be inferred from their usage. This is
similar to <code>let v = Vec::new();</code> needing either type annotations or values of
some type to be inserted into the <code>Vec</code> for Rust to be able to infer the type.</p>
<p>For closure definitions, the compiler will infer one concrete type for each of
their parameters and for their return value. For instance, Listing 13-3 shows
the definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition.
Because there are no type annotations, we can call the closure with any type,
which we’ve done here with <code>String</code> the first time. If we then try to call
<code>example_closure</code> with an integer, we’ll get an error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let example_closure = |x| x;

    let s = example_closure(String::from(&quot;hello&quot;));
    let n = example_closure(5);
<span class="boring">}</span></code></pre>
<p><span class="caption">Listing 13-3: Attempting to call a closure whose types
are inferred with two different types</span></p>
<p>The compiler gives us this error:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
error[E0308]: mismatched types
 --&gt; src/main.rs:5:29
  |
5 |     let n = example_closure(5);
  |                             ^- help: try using a conversion method: `.to_string()`
  |                             |
  |                             expected struct `String`, found integer

For more information about this error, try `rustc --explain E0308`.
error: could not compile `closure-example` due to previous error
</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those
types are then locked into the closure in <code>example_closure</code>, and we get a type
error when we next try to use a different type with the same closure.</p>
<div class="quiz-placeholder" data-quiz-name="ch13-01-closures-sec1"  data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;Rust could, in theory, provide type inference for top-level functions. Functional languages like Haskell and OCaml have this feature.\nHowever, Rust designers made the conscious decision to require type annotations on top-level functions to promote clarity at the \ninterface level: a function will always have exactly the type it says it has.\n&quot;,&quot;id&quot;:&quot;e6cbd582-9692-4045-a984-8770a12e1b95&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;Top-level functions can be part of a library's external interface, while closures cannot be directly exposed&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;Due to the halting problem, it is mathematically impossible for Rust to infer the types of top-level functions&quot;,&quot;For backwards compatibility with older versions of Rust&quot;,&quot;Anything assignable to a variable can be type-inferred, and top-level functions cannot be assigned to a variable&quot;],&quot;prompt&quot;:&quot;Which of the following best describes the rationale for why Rust will infer the types of arguments/returns for closures, but not top-level functions?\n&quot;}},{&quot;context&quot;:&quot;The toilet closure is similar to [`std::mem::drop`](https://doc.rust-lang.org/std/mem/fn.drop.html), i.e. a function that moves\nan argument and causes it to be dropped.\n&quot;,&quot;id&quot;:&quot;f844d1c2-3f63-4cdb-b16e-6e818e996e0d&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`f` causes `s` to be immediately dropped&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`f` has no effect on `s`&quot;,&quot;`f` reads `s` and then throws away the result&quot;,&quot;`f` captures `s` in its environment&quot;],&quot;prompt&quot;:&quot;Rust permits pattern matching within closure arguments, including the use of the underscore. For example, you could write the following:\n\n```rust\nlet f = |_| (); // sometimes called the \&quot;toilet closure\&quot;\nlet s = String::from(\&quot;Hello\&quot;);\nf(s);\n```\n\nWhich of the following best describes the relationship between `f` and `s` in this program?\n&quot;}}]}"  data-quiz-fullscreen=""  data-quiz-cache-answers="" ></div>
<h3 id="capturing-references-or-moving-ownership"><a class="header" href="#capturing-references-or-moving-ownership">Capturing References or Moving Ownership</a></h3>
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: borrowing
immutably, borrowing mutably, and taking ownership. The closure will decide
which of these to use based on what the body of the function does with the
captured values.</p>
<p>In Listing 13-4, we define a closure that captures an immutable reference to
the vector named <code>list</code> because it only needs an immutable reference to print
the value:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let only_borrows = || println!(&quot;From closure: {:?}&quot;, list);

    println!(&quot;Before calling closure: {:?}&quot;, list);
    only_borrows();
    println!(&quot;After calling closure: {:?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Listing 13-4: Defining and calling a closure that
captures an immutable reference</span></p>
<p>This example also illustrates that a variable can bind to a closure definition,
and we can later call the closure by using the variable name and parentheses as
if the variable name were a function name.</p>
<p>Because we can have multiple immutable references to <code>list</code> at the same time,
<code>list</code> is still accessible from the code before the closure definition, after
the closure definition but before the closure is called, and after the closure
is called. This code compiles, runs, and prints:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
Before calling closure: [1, 2, 3]
From closure: [1, 2, 3]
After calling closure: [1, 2, 3]
</code></pre>
<p>Next, in Listing 13-5, we change the closure body so that it adds an element to
the <code>list</code> vector. The closure now captures a mutable reference:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    let mut borrows_mutably = || list.push(7);

    borrows_mutably();
    println!(&quot;After calling closure: {:?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Listing 13-5: Defining and calling a closure that
captures a mutable reference</span></p>
<p>This code compiles, runs, and prints:</p>
<pre><code class="language-console">$ cargo run
   Compiling closure-example v0.1.0 (file:///projects/closure-example)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]
</code></pre>
<p>Note that there’s no longer a <code>println!</code> between the definition and the call of
the <code>borrows_mutably</code> closure: when <code>borrows_mutably</code> is defined, it captures a
mutable reference to <code>list</code>. We don’t use the closure again after the closure
is called, so the mutable borrow ends. Between the closure definition and the
closure call, an immutable borrow to print isn’t allowed because no other
borrows are allowed when there’s a mutable borrow. Try adding a <code>println!</code>
there to see what error message you get!</p>
<p>If you want to force the closure to take ownership of the values it uses in the
environment even though the body of the closure doesn’t strictly need
ownership, you can use the <code>move</code> keyword before the parameter list.</p>
<p>This technique is mostly useful when passing a closure to a new thread to move
the data so that it’s owned by the new thread. We’ll discuss threads and why
you would want to use them in detail in Chapter 16 when we talk about
concurrency, but for now, let’s briefly explore spawning a new thread using a
closure that needs the <code>move</code> keyword. Listing 13-6 shows Listing 13-4 modified
to print the vector in a new thread rather than in the main thread:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">use std::thread;

fn main() {
    let list = vec![1, 2, 3];
    println!(&quot;Before defining closure: {:?}&quot;, list);

    thread::spawn(move || println!(&quot;From thread: {:?}&quot;, list))
        .join()
        .unwrap();
}</code></pre></pre>
<p><span class="caption">Listing 13-6: Using <code>move</code> to force the closure for the
thread to take ownership of <code>list</code></span></p>
<p>We spawn a new thread, giving the thread a closure to run as an argument. The
closure body prints out the list. In Listing 13-4, the closure only captured
<code>list</code> using an immutable reference because that's the least amount of access
to <code>list</code> needed to print it. In this example, even though the closure body
still only needs an immutable reference, we need to specify that <code>list</code> should
be moved into the closure by putting the <code>move</code> keyword at the beginning of the
closure definition. The new thread might finish before the rest of the main
thread finishes, or the main thread might finish first. If the main thread
maintained ownership of <code>list</code> but ended before the new thread did and dropped
<code>list</code>, the immutable reference in the thread would be invalid. Therefore, the
compiler requires that <code>list</code> be moved into the closure given to the new thread
so the reference will be valid. Try removing the <code>move</code> keyword or using <code>list</code>
in the main thread after the closure is defined to see what compiler errors you
get!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a></p>
<h3 id="moving-captured-values-out-of-closures-and-the-fn-traits"><a class="header" href="#moving-captured-values-out-of-closures-and-the-fn-traits">Moving Captured Values Out of Closures and the <code>Fn</code> Traits</a></h3>
<p>Once a closure has captured a reference or captured ownership of a value from
the environment where the closure is defined (thus affecting what, if anything,
is moved <em>into</em> the closure), the code in the body of the closure defines what
happens to the references or values when the closure is evaluated later (thus
affecting what, if anything, is moved <em>out of</em> the closure). A closure body can
do any of the following: move a captured value out of the closure, mutate the
captured value, neither move nor mutate the value, or capture nothing from the
environment to begin with.</p>
<p>The way a closure captures and handles values from the environment affects
which traits the closure implements, and traits are how functions and structs
can specify what kinds of closures they can use. Closures will automatically
implement one, two, or all three of these <code>Fn</code> traits, in an additive fashion,
depending on how the closure’s body handles the values:</p>
<ol>
<li><code>FnOnce</code> applies to closures that can be called once. All closures implement
at least this trait, because all closures can be called. A closure that
moves captured values out of its body will only implement <code>FnOnce</code> and none
of the other <code>Fn</code> traits, because it can only be called once.</li>
<li><code>FnMut</code> applies to closures that don’t move captured values out of their
body, but that might mutate the captured values. These closures can be
called more than once.</li>
<li><code>Fn</code> applies to closures that don’t move captured values out of their body
and that don’t mutate captured values, as well as closures that capture
nothing from their environment. These closures can be called more than once
without mutating their environment, which is important in cases such as
calling a closure multiple times concurrently.</li>
</ol>
<p>Let’s look at the definition of the <code>unwrap_or_else</code> method on <code>Option&lt;T&gt;</code> that
we used in Listing 13-1:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T
    {
        match self {
            Some(x) =&gt; x,
            None =&gt; f(),
        }
    }
}</code></pre>
<p>Recall that <code>T</code> is the generic type representing the type of the value in the
<code>Some</code> variant of an <code>Option</code>. That type <code>T</code> is also the return type of the
<code>unwrap_or_else</code> function: code that calls <code>unwrap_or_else</code> on an
<code>Option&lt;String&gt;</code>, for example, will get a <code>String</code>.</p>
<p>Next, notice that the <code>unwrap_or_else</code> function has the additional generic type
parameter <code>F</code>. The <code>F</code> type is the type of the parameter named <code>f</code>, which is
the closure we provide when calling <code>unwrap_or_else</code>.</p>
<p>The trait bound specified on the generic type <code>F</code> is <code>FnOnce() -&gt; T</code>, which
means <code>F</code> must be able to be called once, take no arguments, and return a <code>T</code>.
Using <code>FnOnce</code> in the trait bound expresses the constraint that
<code>unwrap_or_else</code> is only going to call <code>f</code> at most one time. In the body of
<code>unwrap_or_else</code>, we can see that if the <code>Option</code> is <code>Some</code>, <code>f</code> won’t be
called. If the <code>Option</code> is <code>None</code>, <code>f</code> will be called once. Because all
closures implement <code>FnOnce</code>, <code>unwrap_or_else</code> accepts the most different kinds
of closures and is as flexible as it can be.</p>
<blockquote>
<p>Note: Functions can implement all three of the <code>Fn</code> traits too. If what we
want to do doesn’t require capturing a value from the environment, we can use
the name of a function rather than a closure where we need something that
implements one of the <code>Fn</code> traits. For example, on an <code>Option&lt;Vec&lt;T&gt;&gt;</code> value,
we could call <code>unwrap_or_else(Vec::new)</code> to get a new, empty vector if the
value is <code>None</code>.</p>
</blockquote>
<p>Now let’s look at the standard library method <code>sort_by_key</code> defined on slices,
to see how that differs from <code>unwrap_or_else</code> and why <code>sort_by_key</code> uses
<code>FnMut</code> instead of <code>FnOnce</code> for the trait bound. The closure gets one argument
in the form of a reference to the current item in the slice being considered,
and returns a value of type <code>K</code> that can be ordered. This function is useful
when you want to sort a slice by a particular attribute of each item. In
Listing 13-7, we have a list of <code>Rectangle</code> instances and we use <code>sort_by_key</code>
to order them by their <code>width</code> attribute from low to high:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    list.sort_by_key(|r| r.width);
    println!(&quot;{:#?}&quot;, list);
}</code></pre></pre>
<p><span class="caption">Listing 13-7: Using <code>sort_by_key</code> to order rectangles by
width</span></p>
<p>This code prints:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
    Finished dev [unoptimized + debuginfo] target(s) in 0.41s
     Running `target/debug/rectangles`
[
    Rectangle {
        width: 3,
        height: 5,
    },
    Rectangle {
        width: 7,
        height: 12,
    },
    Rectangle {
        width: 10,
        height: 1,
    },
]
</code></pre>
<p>The reason <code>sort_by_key</code> is defined to take an <code>FnMut</code> closure is that it calls
the closure multiple times: once for each item in the slice. The closure <code>|r| r.width</code> doesn’t capture, mutate, or move out anything from its environment, so
it meets the trait bound requirements.</p>
<p>In contrast, Listing 13-8 shows an example of a closure that implements just
the <code>FnOnce</code> trait, because it moves a value out of the environment. The
compiler won’t let us use this closure with <code>sort_by_key</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut sort_operations = vec![];
    let value = String::from(&quot;by key called&quot;);

    list.sort_by_key(|r| {
        sort_operations.push(value);
        r.width
    });
    println!(&quot;{:#?}&quot;, list);
}</code></pre>
<p><span class="caption">Listing 13-8: Attempting to use an <code>FnOnce</code> closure with
<code>sort_by_key</code></span></p>
<p>This is a contrived, convoluted way (that doesn’t work) to try and count the
number of times <code>sort_by_key</code> gets called when sorting <code>list</code>. This code
attempts to do this counting by pushing <code>value</code>—a <code>String</code> from the closure’s
environment—into the <code>sort_operations</code> vector. The closure captures <code>value</code>
then moves <code>value</code> out of the closure by transferring ownership of <code>value</code> to
the <code>sort_operations</code> vector. This closure can be called once; trying to call
it a second time wouldn’t work because <code>value</code> would no longer be in the
environment to be pushed into <code>sort_operations</code> again! Therefore, this closure
only implements <code>FnOnce</code>. When we try to compile this code, we get this error
that <code>value</code> can’t be moved out of the closure because the closure must
implement <code>FnMut</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling rectangles v0.1.0 (file:///projects/rectangles)
error[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure
  --&gt; src/main.rs:18:30
   |
15 |       let value = String::from(&quot;by key called&quot;);
   |           ----- captured outer variable
16 | 
17 |       list.sort_by_key(|r| {
   |  ______________________-
18 | |         sort_operations.push(value);
   | |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait
19 | |         r.width
20 | |     });
   | |_____- captured by this `FnMut` closure

For more information about this error, try `rustc --explain E0507`.
error: could not compile `rectangles` due to previous error
</code></pre>
<p>The error points to the line in the closure body that moves <code>value</code> out of the
environment. To fix this, we need to change the closure body so that it doesn’t
move values out of the environment. To count the number of times <code>sort_by_key</code>
is called, keeping a counter in the environment and incrementing its value in
the closure body is a more straightforward way to calculate that. The closure
in Listing 13-9 works with <code>sort_by_key</code> because it is only capturing a mutable
reference to the <code>num_sort_operations</code> counter and can therefore be called more
than once:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let mut list = [
        Rectangle { width: 10, height: 1 },
        Rectangle { width: 3, height: 5 },
        Rectangle { width: 7, height: 12 },
    ];

    let mut num_sort_operations = 0;
    list.sort_by_key(|r| {
        num_sort_operations += 1;
        r.width
    });
    println!(&quot;{:#?}, sorted in {num_sort_operations} operations&quot;, list);
}</code></pre></pre>
<p><span class="caption">Listing 13-9: Using an <code>FnMut</code> closure with <code>sort_by_key</code>
is allowed</span></p>
<h3 id="closures-must-name-captured-lifetimes"><a class="header" href="#closures-must-name-captured-lifetimes">Closures Must Name Captured Lifetimes</a></h3>
<p>When you start designing functions that accept or return closures, you'll need to think about the lifetime of data captured by the closure. For example, here is a simple program that is supposed to return a closure that clones a string:</p>
<pre><code class="language-rust ignore should_fail">fn make_a_cloner(s_ref: &amp;str) -&gt; impl Fn() -&gt; String {
    move || s_ref.to_string()
}</code></pre>
<p>However, this program is rejected by the compiler with the following error:</p>
<pre><code class="language-text">error[E0700]: hidden type for `impl Fn() -&gt; String` captures lifetime that does not appear in bounds
 --&gt; test.rs:2:5
  |
1 | fn make_a_cloner(s_ref: &amp;str) -&gt; impl Fn() -&gt; String {
  |                         ---- hidden type `[closure@test.rs:2:5: 2:12]` captures the anonymous lifetime defined here
2 |     move || s_ref.to_string()
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<p>This error might be a bit confusing. What is a hidden type? Why does it capture a lifetime? Why does that lifetime need to appear in a bound?</p>
<p>To answer those questions, let's start by seeing what would happen if Rust allowed <code>make_a_cloner</code> to compile. Then we could write the following unsafe program:</p>
<div class="aquascope-embed" data-code="&quot;fn make_a_cloner(s_ref: &amp;str) -&gt; impl Fn() -&gt; String {\n    move || {\n        s_ref.to_string()\n    }\n}\n\nfn main() {\n    let s_own = String::from(\&quot;Hello world\&quot;);\n    let cloner = make_a_cloner(&amp;s_own);\n    drop(s_own);\n    cloner();\n}&quot;"  data-annotations="{&quot;hidden_lines&quot;:[],&quot;interp&quot;:{&quot;state_locations&quot;:[94,200,217]},&quot;stepper&quot;:{&quot;focused_lines&quot;:[],&quot;focused_paths&quot;:{}},&quot;boundaries&quot;:{&quot;focused_lines&quot;:[]}}"  data-operations="[&quot;interpreter&quot;]"  data-responses="{&quot;interpreter&quot;:{&quot;Ok&quot;:{&quot;result&quot;:{&quot;type&quot;:&quot;Error&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;PointerUseAfterFree&quot;,&quot;value&quot;:{&quot;alloc_id&quot;:0}}},&quot;steps&quot;:[{&quot;heap&quot;:{&quot;locations&quot;:[]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[],&quot;location&quot;:{&quot;end&quot;:113,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;name&quot;:&quot;main&quot;}]}},{&quot;heap&quot;:{&quot;locations&quot;:[{&quot;type&quot;:&quot;Array&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;All&quot;,&quot;value&quot;:[{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:72},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:101},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:32},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:119},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:114},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:100}]}}]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;s_own&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:{&quot;type&quot;:&quot;String&quot;,&quot;value&quot;:{&quot;len&quot;:11}},&quot;fields&quot;:[[&quot;vec&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;buf&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;ptr&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Pointer&quot;,&quot;value&quot;:{&quot;path&quot;:{&quot;parts&quot;:[{&quot;type&quot;:&quot;Index&quot;,&quot;value&quot;:0}],&quot;segment&quot;:{&quot;type&quot;:&quot;Heap&quot;,&quot;value&quot;:{&quot;index&quot;:0}}},&quot;range&quot;:null}}]],&quot;name&quot;:&quot;NonNull&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;Unique&quot;,&quot;variant&quot;:null}}],[&quot;cap&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;RawVec&quot;,&quot;variant&quot;:null}}],[&quot;len&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;Vec&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;String&quot;,&quot;variant&quot;:null}}}],&quot;location&quot;:{&quot;end&quot;:160,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:120},&quot;name&quot;:&quot;main&quot;}]}},{&quot;heap&quot;:{&quot;locations&quot;:[{&quot;type&quot;:&quot;Array&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;All&quot;,&quot;value&quot;:[{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:72},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:101},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:32},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:119},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:114},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:100}]}}]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;s_own&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:{&quot;type&quot;:&quot;String&quot;,&quot;value&quot;:{&quot;len&quot;:11}},&quot;fields&quot;:[[&quot;vec&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;buf&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;ptr&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Pointer&quot;,&quot;value&quot;:{&quot;path&quot;:{&quot;parts&quot;:[{&quot;type&quot;:&quot;Index&quot;,&quot;value&quot;:0}],&quot;segment&quot;:{&quot;type&quot;:&quot;Heap&quot;,&quot;value&quot;:{&quot;index&quot;:0}}},&quot;range&quot;:null}}]],&quot;name&quot;:&quot;NonNull&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;Unique&quot;,&quot;variant&quot;:null}}],[&quot;cap&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;RawVec&quot;,&quot;variant&quot;:null}}],[&quot;len&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;Vec&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;String&quot;,&quot;variant&quot;:null}}}],&quot;location&quot;:{&quot;end&quot;:200,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:165},&quot;name&quot;:&quot;main&quot;}]}},{&quot;heap&quot;:{&quot;locations&quot;:[{&quot;type&quot;:&quot;Array&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;All&quot;,&quot;value&quot;:[{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:72},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:101},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:32},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:119},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:114},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:100}]}}]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;s_own&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:{&quot;type&quot;:&quot;String&quot;,&quot;value&quot;:{&quot;len&quot;:11}},&quot;fields&quot;:[[&quot;vec&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;buf&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;ptr&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Pointer&quot;,&quot;value&quot;:{&quot;path&quot;:{&quot;parts&quot;:[{&quot;type&quot;:&quot;Index&quot;,&quot;value&quot;:0}],&quot;segment&quot;:{&quot;type&quot;:&quot;Heap&quot;,&quot;value&quot;:{&quot;index&quot;:0}}},&quot;range&quot;:null}}]],&quot;name&quot;:&quot;NonNull&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;Unique&quot;,&quot;variant&quot;:null}}],[&quot;cap&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;RawVec&quot;,&quot;variant&quot;:null}}],[&quot;len&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;Vec&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;String&quot;,&quot;variant&quot;:null}}}],&quot;location&quot;:{&quot;end&quot;:200,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:165},&quot;name&quot;:&quot;main&quot;},{&quot;body_span&quot;:{&quot;end&quot;:102,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:0},&quot;locals&quot;:[{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;s_ref&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Pointer&quot;,&quot;value&quot;:{&quot;path&quot;:{&quot;parts&quot;:[{&quot;type&quot;:&quot;Subslice&quot;,&quot;value&quot;:[0,10]}],&quot;segment&quot;:{&quot;type&quot;:&quot;Heap&quot;,&quot;value&quot;:{&quot;index&quot;:0}}},&quot;range&quot;:11}}}],&quot;location&quot;:{&quot;end&quot;:52,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:0},&quot;name&quot;:&quot;make_a_cloner&quot;}]}},{&quot;heap&quot;:{&quot;locations&quot;:[{&quot;type&quot;:&quot;Array&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;All&quot;,&quot;value&quot;:[{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:72},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:101},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:32},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:119},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:114},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:100}]}}]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;s_own&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:{&quot;type&quot;:&quot;String&quot;,&quot;value&quot;:{&quot;len&quot;:11}},&quot;fields&quot;:[[&quot;vec&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;buf&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;ptr&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Pointer&quot;,&quot;value&quot;:{&quot;path&quot;:{&quot;parts&quot;:[{&quot;type&quot;:&quot;Index&quot;,&quot;value&quot;:0}],&quot;segment&quot;:{&quot;type&quot;:&quot;Heap&quot;,&quot;value&quot;:{&quot;index&quot;:0}}},&quot;range&quot;:null}}]],&quot;name&quot;:&quot;NonNull&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;Unique&quot;,&quot;variant&quot;:null}}],[&quot;cap&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;RawVec&quot;,&quot;variant&quot;:null}}],[&quot;len&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;Vec&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;String&quot;,&quot;variant&quot;:null}}}],&quot;location&quot;:{&quot;end&quot;:200,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:165},&quot;name&quot;:&quot;main&quot;},{&quot;body_span&quot;:{&quot;end&quot;:102,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:0},&quot;locals&quot;:[{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;(return)&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;s_ref&quot;,{&quot;type&quot;:&quot;Pointer&quot;,&quot;value&quot;:{&quot;path&quot;:{&quot;parts&quot;:[{&quot;type&quot;:&quot;Subslice&quot;,&quot;value&quot;:[0,10]}],&quot;segment&quot;:{&quot;type&quot;:&quot;Heap&quot;,&quot;value&quot;:{&quot;index&quot;:0}}},&quot;range&quot;:11}}]],&quot;name&quot;:&quot;make_a_cloner::{closure#0}&quot;,&quot;variant&quot;:null}}},{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;s_ref&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Pointer&quot;,&quot;value&quot;:{&quot;path&quot;:{&quot;parts&quot;:[{&quot;type&quot;:&quot;Subslice&quot;,&quot;value&quot;:[0,10]}],&quot;segment&quot;:{&quot;type&quot;:&quot;Heap&quot;,&quot;value&quot;:{&quot;index&quot;:0}}},&quot;range&quot;:11}}}],&quot;location&quot;:{&quot;end&quot;:66,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:59},&quot;name&quot;:&quot;make_a_cloner&quot;}]}},{&quot;heap&quot;:{&quot;locations&quot;:[{&quot;type&quot;:&quot;Array&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;All&quot;,&quot;value&quot;:[{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:72},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:101},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:32},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:119},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:111},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:114},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:108},{&quot;type&quot;:&quot;Char&quot;,&quot;value&quot;:100}]}}]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;s_own&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:{&quot;type&quot;:&quot;String&quot;,&quot;value&quot;:{&quot;len&quot;:11}},&quot;fields&quot;:[[&quot;vec&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;buf&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;ptr&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Pointer&quot;,&quot;value&quot;:{&quot;path&quot;:{&quot;parts&quot;:[{&quot;type&quot;:&quot;Index&quot;,&quot;value&quot;:0}],&quot;segment&quot;:{&quot;type&quot;:&quot;Heap&quot;,&quot;value&quot;:{&quot;index&quot;:0}}},&quot;range&quot;:null}}]],&quot;name&quot;:&quot;NonNull&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;Unique&quot;,&quot;variant&quot;:null}}],[&quot;cap&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;RawVec&quot;,&quot;variant&quot;:null}}],[&quot;len&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;Vec&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;String&quot;,&quot;variant&quot;:null}}},{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;cloner&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;s_ref&quot;,{&quot;type&quot;:&quot;Pointer&quot;,&quot;value&quot;:{&quot;path&quot;:{&quot;parts&quot;:[{&quot;type&quot;:&quot;Subslice&quot;,&quot;value&quot;:[0,10]}],&quot;segment&quot;:{&quot;type&quot;:&quot;Heap&quot;,&quot;value&quot;:{&quot;index&quot;:0}}},&quot;range&quot;:11}}]],&quot;name&quot;:&quot;make_a_cloner::{closure#0}&quot;,&quot;variant&quot;:null}}}],&quot;location&quot;:{&quot;end&quot;:200,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:165},&quot;name&quot;:&quot;main&quot;}]}},{&quot;heap&quot;:{&quot;locations&quot;:[]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[{&quot;moved_paths&quot;:[[]],&quot;name&quot;:&quot;s_own&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:{&quot;type&quot;:&quot;String&quot;,&quot;value&quot;:{&quot;len&quot;:11}},&quot;fields&quot;:[[&quot;vec&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;buf&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;ptr&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Unallocated&quot;,&quot;value&quot;:{&quot;alloc_id&quot;:0}}]],&quot;name&quot;:&quot;NonNull&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;Unique&quot;,&quot;variant&quot;:null}}],[&quot;cap&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;RawVec&quot;,&quot;variant&quot;:null}}],[&quot;len&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;Vec&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;String&quot;,&quot;variant&quot;:null}}},{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;cloner&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;s_ref&quot;,{&quot;type&quot;:&quot;Unallocated&quot;,&quot;value&quot;:{&quot;alloc_id&quot;:0}}]],&quot;name&quot;:&quot;make_a_cloner::{closure#0}&quot;,&quot;variant&quot;:null}}}],&quot;location&quot;:{&quot;end&quot;:217,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:205},&quot;name&quot;:&quot;main&quot;}]}},{&quot;heap&quot;:{&quot;locations&quot;:[]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[{&quot;moved_paths&quot;:[[]],&quot;name&quot;:&quot;s_own&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:{&quot;type&quot;:&quot;String&quot;,&quot;value&quot;:{&quot;len&quot;:11}},&quot;fields&quot;:[[&quot;vec&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;buf&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;ptr&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Unallocated&quot;,&quot;value&quot;:{&quot;alloc_id&quot;:0}}]],&quot;name&quot;:&quot;NonNull&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;Unique&quot;,&quot;variant&quot;:null}}],[&quot;cap&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;RawVec&quot;,&quot;variant&quot;:null}}],[&quot;len&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;Vec&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;String&quot;,&quot;variant&quot;:null}}},{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;cloner&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;s_ref&quot;,{&quot;type&quot;:&quot;Unallocated&quot;,&quot;value&quot;:{&quot;alloc_id&quot;:0}}]],&quot;name&quot;:&quot;make_a_cloner::{closure#0}&quot;,&quot;variant&quot;:null}}}],&quot;location&quot;:{&quot;end&quot;:231,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:222},&quot;name&quot;:&quot;main&quot;}]}},{&quot;heap&quot;:{&quot;locations&quot;:[]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[{&quot;moved_paths&quot;:[[]],&quot;name&quot;:&quot;s_own&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:{&quot;type&quot;:&quot;String&quot;,&quot;value&quot;:{&quot;len&quot;:11}},&quot;fields&quot;:[[&quot;vec&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;buf&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;ptr&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Unallocated&quot;,&quot;value&quot;:{&quot;alloc_id&quot;:0}}]],&quot;name&quot;:&quot;NonNull&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;Unique&quot;,&quot;variant&quot;:null}}],[&quot;cap&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;RawVec&quot;,&quot;variant&quot;:null}}],[&quot;len&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;Vec&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;String&quot;,&quot;variant&quot;:null}}},{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;cloner&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;s_ref&quot;,{&quot;type&quot;:&quot;Unallocated&quot;,&quot;value&quot;:{&quot;alloc_id&quot;:0}}]],&quot;name&quot;:&quot;make_a_cloner::{closure#0}&quot;,&quot;variant&quot;:null}}}],&quot;location&quot;:{&quot;end&quot;:231,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:222},&quot;name&quot;:&quot;main&quot;},{&quot;body_span&quot;:{&quot;end&quot;:100,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:59},&quot;locals&quot;:[],&quot;location&quot;:{&quot;end&quot;:66,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:59},&quot;name&quot;:&quot;make_a_cloner::{closure#0}&quot;}]}},{&quot;heap&quot;:{&quot;locations&quot;:[]},&quot;stack&quot;:{&quot;frames&quot;:[{&quot;body_span&quot;:{&quot;end&quot;:233,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;locals&quot;:[{&quot;moved_paths&quot;:[[]],&quot;name&quot;:&quot;s_own&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:{&quot;type&quot;:&quot;String&quot;,&quot;value&quot;:{&quot;len&quot;:11}},&quot;fields&quot;:[[&quot;vec&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;buf&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;ptr&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;pointer&quot;,{&quot;type&quot;:&quot;Unallocated&quot;,&quot;value&quot;:{&quot;alloc_id&quot;:0}}]],&quot;name&quot;:&quot;NonNull&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;Unique&quot;,&quot;variant&quot;:null}}],[&quot;cap&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;RawVec&quot;,&quot;variant&quot;:null}}],[&quot;len&quot;,{&quot;type&quot;:&quot;Uint&quot;,&quot;value&quot;:11}]],&quot;name&quot;:&quot;Vec&quot;,&quot;variant&quot;:null}}]],&quot;name&quot;:&quot;String&quot;,&quot;variant&quot;:null}}},{&quot;moved_paths&quot;:[],&quot;name&quot;:&quot;cloner&quot;,&quot;value&quot;:{&quot;type&quot;:&quot;Adt&quot;,&quot;value&quot;:{&quot;alloc_kind&quot;:null,&quot;fields&quot;:[[&quot;s_ref&quot;,{&quot;type&quot;:&quot;Unallocated&quot;,&quot;value&quot;:{&quot;alloc_id&quot;:0}}]],&quot;name&quot;:&quot;make_a_cloner::{closure#0}&quot;,&quot;variant&quot;:null}}}],&quot;location&quot;:{&quot;end&quot;:231,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:222},&quot;name&quot;:&quot;main&quot;},{&quot;body_span&quot;:{&quot;end&quot;:100,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:59},&quot;locals&quot;:[],&quot;location&quot;:{&quot;end&quot;:94,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:77},&quot;name&quot;:&quot;make_a_cloner::{closure#0}&quot;}]}}]}}}"  data-config="{&quot;shouldFail&quot;:&quot;true&quot;}"  data-no-interact="true" ></div>
<p>Let's follow the execution. After calling <code>make_a_cloner(&amp;s_own)</code>, at L1 we get back a closure <code>cloner</code>. Within the closure is its environment, the reference <code>s_ref</code>. However, if we are allowed to drop <code>s_own</code> at L2, then that invalidates <code>cloner</code> because its environment contains a pointer to deallocated memory. Then invoking <code>cloner()</code> would cause a use-after-free.</p>
<p>Returning to the original type error, the issue is that <strong>we need to tell Rust that the closure returned from <code>make_a_cloner</code> must not live longer than <code>s_ref</code>.</strong> We can do that explicitly using a lifetime parameter like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//              vvvv         vv                             vvvv                
fn make_a_cloner&lt;'a&gt;(s_ref: &amp;'a str) -&gt; impl Fn() -&gt; String + 'a {
    move || s_ref.to_string()
}
<span class="boring">}</span></code></pre></pre>
<p>These changes say: <code>s_ref</code> is a string reference that lives for <code>'a</code>. Adding <code>+ 'a</code> to the return type's trait bounds indicates that the closure must live no longer than <code>'a</code>. Therefore Rust deduces this function is now safe. If we try to use it unsafely like before:</p>
<div class="aquascope-embed" data-code="&quot;fn make_a_cloner&lt;'a&gt;(s_ref: &amp;'a str) \n    -&gt; impl Fn() -&gt; String + 'a \n{\n    move || s_ref.to_string()\n}\nfn main() {\nlet s_own = String::from(\&quot;Hello world\&quot;);\nlet cloner = make_a_cloner(&amp;s_own);\ndrop(s_own);\ncloner();\n}&quot;"  data-annotations="{&quot;hidden_lines&quot;:[1,2,3,4,5,6,11],&quot;interp&quot;:{&quot;state_locations&quot;:[]},&quot;stepper&quot;:{&quot;focused_lines&quot;:[],&quot;focused_paths&quot;:{}},&quot;boundaries&quot;:{&quot;focused_lines&quot;:[9]}}"  data-operations="[&quot;permissions&quot;]"  data-responses="{&quot;permissions&quot;:[{&quot;Ok&quot;:{&quot;body_range&quot;:{&quot;end&quot;:102,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:77},&quot;boundaries&quot;:[],&quot;loan_points&quot;:{},&quot;loan_regions&quot;:{},&quot;move_points&quot;:{},&quot;move_regions&quot;:{},&quot;steps&quot;:[]}},{&quot;Ok&quot;:{&quot;body_range&quot;:{&quot;end&quot;:104,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:0},&quot;boundaries&quot;:[],&quot;loan_points&quot;:{},&quot;loan_regions&quot;:{},&quot;move_points&quot;:{},&quot;move_regions&quot;:{},&quot;steps&quot;:[{&quot;location&quot;:{&quot;end&quot;:102,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:102},&quot;state&quot;:[{&quot;from&quot;:{&quot;end&quot;:102,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:77},&quot;state&quot;:[[&quot;s_ref&quot;,{&quot;is_live&quot;:{&quot;type&quot;:&quot;Low&quot;},&quot;loan_drop_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_read_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_write_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_moved&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_uninitialized&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;permissions&quot;:{&quot;drop&quot;:{&quot;type&quot;:&quot;Low&quot;},&quot;read&quot;:{&quot;type&quot;:&quot;Low&quot;},&quot;write&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}},&quot;type_droppable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:true},&quot;type_writeable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}}],[&quot;*s_ref&quot;,{&quot;is_live&quot;:{&quot;type&quot;:&quot;Low&quot;},&quot;loan_drop_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_read_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_write_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_moved&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_uninitialized&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;permissions&quot;:{&quot;drop&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;read&quot;:{&quot;type&quot;:&quot;Low&quot;},&quot;write&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}},&quot;type_droppable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;type_writeable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}}]],&quot;to&quot;:{&quot;end&quot;:104,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104}}]},{&quot;location&quot;:{&quot;end&quot;:104,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;state&quot;:[{&quot;from&quot;:{&quot;end&quot;:104,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:104},&quot;state&quot;:[[&quot;s_ref&quot;,{&quot;is_live&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;loan_drop_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_read_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_write_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_moved&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_uninitialized&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;permissions&quot;:{&quot;drop&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;read&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;write&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}},&quot;type_droppable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:true},&quot;type_writeable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}}],[&quot;*s_ref&quot;,{&quot;is_live&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;loan_drop_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_read_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_write_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_moved&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_uninitialized&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;permissions&quot;:{&quot;drop&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;read&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;write&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}},&quot;type_droppable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;type_writeable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}}]],&quot;to&quot;:{&quot;end&quot;:102,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:77}}]},{&quot;location&quot;:{&quot;end&quot;:72,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:72},&quot;state&quot;:[{&quot;from&quot;:{&quot;end&quot;:102,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:77},&quot;state&quot;:[[&quot;s_ref&quot;,{&quot;is_live&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;loan_drop_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_read_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_write_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_moved&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_uninitialized&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;permissions&quot;:{&quot;drop&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;read&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;write&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}},&quot;type_droppable&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;type_writeable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}}],[&quot;*s_ref&quot;,{&quot;is_live&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;loan_drop_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_read_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_write_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_moved&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_uninitialized&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;permissions&quot;:{&quot;drop&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;read&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;write&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}},&quot;type_droppable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;type_writeable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}}]],&quot;to&quot;:{&quot;end&quot;:102,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:77}}]}]}},{&quot;Ok&quot;:{&quot;body_range&quot;:{&quot;end&quot;:218,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:105},&quot;boundaries&quot;:[{&quot;actual&quot;:{&quot;is_live&quot;:true,&quot;path_uninitialized&quot;:false,&quot;permissions&quot;:{&quot;drop&quot;:true,&quot;read&quot;:true,&quot;write&quot;:false},&quot;type_copyable&quot;:false,&quot;type_droppable&quot;:true,&quot;type_writeable&quot;:false},&quot;expected&quot;:{&quot;drop&quot;:false,&quot;read&quot;:true,&quot;write&quot;:false},&quot;location&quot;:186},{&quot;actual&quot;:{&quot;is_live&quot;:true,&quot;loan_drop_refined&quot;:0,&quot;loan_write_refined&quot;:0,&quot;path_uninitialized&quot;:false,&quot;permissions&quot;:{&quot;drop&quot;:false,&quot;read&quot;:true,&quot;write&quot;:false},&quot;type_copyable&quot;:false,&quot;type_droppable&quot;:true,&quot;type_writeable&quot;:false},&quot;expected&quot;:{&quot;drop&quot;:true,&quot;read&quot;:true,&quot;write&quot;:false},&quot;location&quot;:199}],&quot;loan_points&quot;:{&quot;0&quot;:{&quot;end&quot;:191,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:185},&quot;1&quot;:{&quot;end&quot;:213,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:207}},&quot;loan_regions&quot;:{&quot;0&quot;:{&quot;refined_ranges&quot;:[{&quot;end&quot;:191,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:185},{&quot;end&quot;:205,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:194},{&quot;end&quot;:215,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:207}],&quot;refiner_point&quot;:{&quot;Loan&quot;:0}},&quot;1&quot;:{&quot;refined_ranges&quot;:[{&quot;end&quot;:215,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:207}],&quot;refiner_point&quot;:{&quot;Loan&quot;:1}}},&quot;move_points&quot;:{},&quot;move_regions&quot;:{},&quot;steps&quot;:[{&quot;location&quot;:{&quot;end&quot;:157,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:157},&quot;state&quot;:[{&quot;from&quot;:{&quot;end&quot;:126,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:121},&quot;state&quot;:[[&quot;s_own&quot;,{&quot;is_live&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;loan_drop_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_read_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_write_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_moved&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_uninitialized&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;permissions&quot;:{&quot;drop&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;read&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;write&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}},&quot;type_droppable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:true},&quot;type_writeable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}}]],&quot;to&quot;:{&quot;end&quot;:168,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:162}}]},{&quot;location&quot;:{&quot;end&quot;:193,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:193},&quot;state&quot;:[{&quot;from&quot;:{&quot;end&quot;:168,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:162},&quot;state&quot;:[[&quot;s_own&quot;,{&quot;is_live&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:true},&quot;loan_drop_refined&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:0},&quot;loan_read_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_write_refined&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:0},&quot;path_moved&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_uninitialized&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false},&quot;permissions&quot;:{&quot;drop&quot;:{&quot;type&quot;:&quot;Low&quot;},&quot;read&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:true},&quot;write&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}},&quot;type_droppable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:true},&quot;type_writeable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}}],[&quot;cloner&quot;,{&quot;is_live&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;loan_drop_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_read_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;loan_write_refined&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_moved&quot;:{&quot;type&quot;:&quot;None&quot;},&quot;path_uninitialized&quot;:{&quot;type&quot;:&quot;Low&quot;},&quot;permissions&quot;:{&quot;drop&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;read&quot;:{&quot;type&quot;:&quot;High&quot;,&quot;value&quot;:true},&quot;write&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}},&quot;type_droppable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:true},&quot;type_writeable&quot;:{&quot;type&quot;:&quot;None&quot;,&quot;value&quot;:false}}]],&quot;to&quot;:{&quot;end&quot;:205,&quot;filename&quot;:{&quot;private&quot;:0},&quot;start&quot;:194}}]}]}}]}"  data-config="{&quot;stepper&quot;:&quot;true&quot;,&quot;boundaries&quot;:&quot;true&quot;}"  data-no-interact="true" ></div>
<p>Rust recognizes that as long as <code>make_a_cloner</code> is in use, <code>s_own</code> cannot be dropped. This is reflected in the permissions: <code>s_own</code> loses the <span class="perm own">O</span> permission after calling <code>make_a_cloner</code>. Consequently, Rust rejects this program with the following error:</p>
<pre><code class="language-text">error[E0505]: cannot move out of `s_own` because it is borrowed
  --&gt; test.rs:9:6
   |
8  | let cloner = make_a_cloner(&amp;s_own);
   |                            ------ borrow of `s_own` occurs here
9  | drop(s_own);
   |      ^^^^^ move out of `s_own` occurs here
10 | cloner();
   | ------ borrow later used here
</code></pre>
<p>Returning now to the original confusing error: the &quot;hidden type&quot; of the closure captured <code>s_ref</code> which had a limited lifetime. The return type never mentioned this lifetime, so Rust could not deduce that <code>make_a_cloner</code> was safe. But if we explicitly say that the closure captures the lifetime of <code>s_ref</code>, then our function compiles.</p>
<p>Note that we can use the <a href="ch10-03-lifetime-syntax.html#lifetime-elision">lifetime elision</a> rules to make the function type more concise. We can remove the <code>&lt;'a&gt;</code> generic so long as we keep an indicator that the returned closure depends on <em>some</em> lifetime, like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_a_cloner(s_ref: &amp;str) -&gt; impl Fn() -&gt; String + '_ {
    move || s_ref.to_string()
}
<span class="boring">}</span></code></pre></pre>
<p>In sum, the <code>Fn</code> traits are important when defining or using functions or types that
make use of closures. In the next section, we’ll discuss iterators. Many
iterator methods take closure arguments, so keep these closure details in mind
as we continue!</p>
<div class="quiz-placeholder" data-quiz-name="ch13-01-closures-sec2"  data-quiz-questions="{&quot;questions&quot;:[{&quot;context&quot;:&quot;`add_suffix` mutably borrows `s` between its definition and use, so the `println` (a read of `s`) is invalid.\n&quot;,&quot;id&quot;:&quot;a055fa7c-89e2-467e-8458-62cbf3ffb8bf&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:false,&quot;lineNumber&quot;:5},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn main() {\n    let mut s = String::from(\&quot;Hello\&quot;);\n    let mut add_suffix = || s.push_str(\&quot; world\&quot;);\n    println!(\&quot;{s}\&quot;);\n    add_suffix();  \n}\n&quot;}},{&quot;context&quot;:&quot;Because `add_suffix` does not capture `s`, it is fine to read `s` before mutating it with `add_suffix`.\n&quot;,&quot;id&quot;:&quot;266d3cb3-de76-4b91-bd13-c3d6cb9e7fd7&quot;,&quot;type&quot;:&quot;Tracing&quot;,&quot;answer&quot;:{&quot;doesCompile&quot;:true,&quot;stdout&quot;:&quot;Hello&quot;},&quot;prompt&quot;:{&quot;program&quot;:&quot;fn main() {\n    let mut s = String::from(\&quot;Hello\&quot;);\n    let add_suffix = |s: &amp;mut String| s.push_str(\&quot; world\&quot;);\n    println!(\&quot;{s}\&quot;);\n    add_suffix(&amp;mut s);  \n}\n&quot;}},{&quot;context&quot;:&quot;`f` is called multiple times so `FnOnce` is not appropriate. Both `Fn` and `FnMut` can work, and `FnMut` is less restrictive, so `FnMut` is most appropriate.\n&quot;,&quot;id&quot;:&quot;0f298680-d870-47a1-962c-1c668f75cb68&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`FnMut`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`Fn`&quot;,&quot;`FnOnce`&quot;],&quot;prompt&quot;:&quot;Consider the following API:\n\n```rust\n/// Executes a function with a mutable reference to each element of a vector\nfn for_each_mut&lt;T, F: ___(&amp;mut T)&gt;(v: &amp;mut Vec&lt;T&gt;, mut f: F) {\n    for x in v.iter_mut() {\n        f(x);\n    }\n}\n```\n\nWhich of the following function traits is most appropriate to fill in the blank?\n&quot;}},{&quot;context&quot;:&quot;`pipeline` could be called multiple times, so `FnOnce` is not appropriate. \n`pipeline` takes an immutable reference to `self`, if `f` were `FnMut`, it could not be called within `pipeline`. \nTherefore `Fn` is most appropriate here.\n&quot;,&quot;id&quot;:&quot;65f574b1-b418-4abe-852e-8b14d88368a7&quot;,&quot;type&quot;:&quot;MultipleChoice&quot;,&quot;answer&quot;:{&quot;answer&quot;:&quot;`Fn`&quot;},&quot;prompt&quot;:{&quot;distractors&quot;:[&quot;`FnMut`&quot;,&quot;`FnOnce`&quot;],&quot;prompt&quot;:&quot;Consider the following API:\n\n```rust\npub struct Analyzer&lt;F&gt; {\n    postprocess: F\n}\n\nimpl&lt;F: ___(i32) -&gt; i32&gt; Analyzer&lt;F&gt; {\n    fn process(&amp;self, n: i32) -&gt; i32 { /* .. */ }\n    pub fn pipeline(&amp;self, n: i32) -&gt; i32 {\n        let n = self.process(n);\n        (self.postprocess)(n)\n    }\n}\n```\n\nWhich of the following function traits is most appropriate to fill in the blank?\n&quot;}}]}"  data-quiz-fullscreen=""  data-quiz-cache-answers="" ></div>
<script type="text/javascript" src="aquascope/lib.js"></script><link rel="stylesheet" type="text/css" href="aquascope/lib.css">
<script type="text/javascript" src="quiz/lib.js"></script><link rel="stylesheet" type="text/css" href="quiz/lib.css">
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-functional-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch13-02-iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-functional-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch13-02-iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>
        <script src="js-extensions/packages/telemetry/dist/index.js"></script>
        <script src="js-extensions/packages/consent-form/dist/index.js"></script>
        <script src="js-extensions/packages/feedback/dist/index.js"></script>


    </body>
</html>
